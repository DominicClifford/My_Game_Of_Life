////Imports required awt(design) functions
import java.awt.Color;
import java.awt.Graphics;
import java.util.Random;

//this is the simulation that will run the Game
public class golSimulation 
{
	//declare the variables
	private golCell[] [] cells;
	private int width;
	private int height;

	//decleare and set count variable
	public static int numberOfRounds = 0;

	public golSimulation() 
	{
		//this create the size of each new cell depending on width and height provided in golFrame class and the size of cells given in golCell
		//width is the width of the frame divided by to size of each cell in the grid
		width = golFrame.WIDTH/golCell.SIZE;
		//height is the height of the frame divided by the size of each cell in the grid
		height = golFrame.HEIGHT - golFrame.PANELSIZE/golCell.SIZE;
		//creates an array to store location of each cell depending on its width and height
		cells = new golCell[width][height];

		//creates ramdom live cells to start the game and increment it by one
		Random random = new Random();
		//X and Y are randomly generated by the program but they must be smaller than thw width and the height
		for(int x = 0;x < width;x++) 
		{
			for (int y = 0; y < height; y++) 
			{
				cells[x] [y] = new golCell(x, y, random.nextBoolean());
			}
		}
	}

	//after each cycle of the simulation this will update which cell is alive and which is dead
	public void update() 
	{
		//the simulation will only run (refresh) if x is less than the width of each cell create above (x will never be greater than width)
		for(int x = 0;x < width;x++) 
		{
			//the simulation will only run (refresh) if x is less than the height of each cell created above (y will never be greater than height)
			for (int y = 0; y < height; y++) 
			{
				int mx = x - 1;
				if(mx < 0) mx = width - 1;
				int my = y - 1;
				if(my < 0) my = height - 1;
				int gx = (x + 1) % width;
				int gy = (y + 1) % height;

				//if below statements are true add 1 to neighborCounter
				//this checks to see whether two cells next to each other are alive (it checks the array)
				int neighborCounter = 0; //resets neighborCounter after each round/generation
				if(cells[mx] [my].aliveCell()) neighborCounter++;
				if(cells[mx] [y].aliveCell()) neighborCounter++; 
				if(cells[mx] [gy].aliveCell()) neighborCounter++; 
				if(cells[x] [my].aliveCell()) neighborCounter++; 
				if(cells[x] [gy].aliveCell()) neighborCounter++; 
				if(cells[gx] [my].aliveCell()) neighborCounter++;
				if(cells[gx] [y].aliveCell()) neighborCounter++; 
				if(cells[gx] [gy].aliveCell()) neighborCounter++; 

				//if neighborcounter of cells is less than 2 or greater than 3 the cell will be dead in next round
				if(neighborCounter < 2 || neighborCounter > 3)
				{
					//add x and y to array and dont set them alive for next round
					cells[x] [y].setNextRound(false);
				}
				//if neighborcounter of cells is = to 2 the cell will be alive in next round
				else if(neighborCounter == 2) 
				{
					//add x and y to array and set them to alive for next round
					cells[x] [y].setNextRound(cells[x] [y].aliveCell()); //keeps the cell alive //returns to golCell class
				}
				else 
				{
					//add x and y to array and keep them the same for next round
					cells[x] [y].setNextRound(true);
				}
			}
		}

		for(int x = 0;x < width;x++) 
		{
			for (int y = 0; y < height; y++) 
			{
				//updates the array with the new locations of cells
				cells[x] [y].update();
			}
		}

		//counts and displays the number of rounds
		numberOfRounds++;
	}

	public void draw(Graphics g) 
	{
		//this sets the colour to red for each alive cell
		for(int x = 0;x < width;x++) 
		{
			for (int y = 0; y < height; y++) 
			{
				g.setColor(Color.RED);	//colour of alive cells
				cells[x] [y].draw(g);
			}
		}			
	}	
}
